<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScriptForge - Written Language Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        h1 {
            font-size: 2.5em;
            color: #ffd700;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            height: fit-content;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 5px;
        }

        .control-item {
            margin-bottom: 15px;
        }

        .control-item label {
            display: block;
            color: #a0a0a0;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .value-display {
            display: inline-block;
            color: #ffd700;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .visualization-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            padding: 20px;
            min-height: 600px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            text-align: center;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #ffd700;
            font-size: 2em;
            font-weight: bold;
        }

        .symbol-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            padding: 20px;
            margin-top: 20px;
        }

        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .symbol-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .symbol-card:hover {
            border-color: #ffd700;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }

        .symbol-canvas {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .symbol-glyph {
            font-size: 2em;
            margin-bottom: 5px;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.3));
        }

        .symbol-meaning {
            color: #a0a0a0;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .symbol-complexity {
            color: #ffd700;
            font-size: 0.7em;
        }

        .evolution-timeline {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            padding: 20px;
            margin-top: 20px;
            min-height: 200px;
        }

        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-panel h4 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .communication-log {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.85em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid rgba(255, 215, 0, 0.5);
            padding-left: 10px;
        }

        .log-success {
            border-left-color: #4ade80;
        }

        .log-innovation {
            border-left-color: #fbbf24;
        }

        .log-evolution {
            border-left-color: #818cf8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚åò ScriptForge ‚åò</h1>
            <p class="subtitle">Watch written language emerge and evolve from pictographs to complex scripts</p>
            <p style="color: #666; font-size: 0.9em; margin-top: 10px;">
                <em>Forge Theory: Complex writing systems emerge from the simple need to communicate</em>
            </p>
        </header>

        <div class="main-grid">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>‚öôÔ∏è Simulation</h3>
                    <button class="btn-primary" id="startBtn">Start Evolution</button>
                    <button class="btn-secondary" id="pauseBtn">Pause</button>
                    <button class="btn-secondary" id="resetBtn">Reset</button>
                </div>

                <div class="control-group">
                    <h3>üì§ Export Script</h3>
                    <button class="btn-secondary" id="exportPngBtn">Export as PNG</button>
                    <button class="btn-secondary" id="exportSvgBtn">Export as SVG</button>
                    <button class="btn-secondary" id="exportJsonBtn">Export Data (JSON)</button>
                    <button class="btn-secondary" id="exportManuscriptBtn">Export Manuscript</button>
                </div>

                <div class="control-group">
                    <h3>üåç Population</h3>
                    <div class="control-item">
                        <label>Cultures: <span class="value-display" id="culturesValue">3</span></label>
                        <input type="range" id="culturesSlider" min="1" max="5" value="3">
                    </div>
                    <div class="control-item">
                        <label>Agents per Culture: <span class="value-display" id="agentsValue">8</span></label>
                        <input type="range" id="agentsSlider" min="4" max="20" value="8">
                    </div>
                    <div class="control-item">
                        <label>Cultural Isolation: <span class="value-display" id="isolationValue">30%</span></label>
                        <input type="range" id="isolationSlider" min="0" max="100" value="30">
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚úèÔ∏è Evolution</h3>
                    <div class="control-item">
                        <label>Simplification Rate: <span class="value-display" id="simplificationValue">50%</span></label>
                        <input type="range" id="simplificationSlider" min="0" max="100" value="50">
                    </div>
                    <div class="control-item">
                        <label>Innovation Rate: <span class="value-display" id="innovationValue">30%</span></label>
                        <input type="range" id="innovationSlider" min="0" max="100" value="30">
                    </div>
                    <div class="control-item">
                        <label>Abstraction Pressure: <span class="value-display" id="abstractionValue">40%</span></label>
                        <input type="range" id="abstractionSlider" min="0" max="100" value="40">
                    </div>
                </div>

                <div class="control-group">
                    <h3>üìö Communication</h3>
                    <div class="control-item">
                        <label>Vocabulary Size: <span class="value-display" id="vocabValue">12</span></label>
                        <input type="range" id="vocabSlider" min="6" max="30" value="12">
                    </div>
                    <div class="control-item">
                        <label>Communication Frequency: <span class="value-display" id="commFreqValue">50%</span></label>
                        <input type="range" id="commFreqSlider" min="10" max="100" value="50">
                    </div>
                </div>

                <div class="info-panel">
                    <h4>üìñ Current Phase</h4>
                    <div id="phaseInfo" style="color: #a0a0a0;">Ready to begin...</div>
                </div>
            </div>

            <div>
                <div class="visualization-area">
                    <canvas id="mainCanvas"></canvas>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Generation</div>
                        <div class="stat-value" id="generationStat">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Active Symbols</div>
                        <div class="stat-value" id="symbolsStat">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg Complexity</div>
                        <div class="stat-value" id="complexityStat">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Script Dialects</div>
                        <div class="stat-value" id="dialectsStat">0</div>
                    </div>
                </div>

                <div class="symbol-display">
                    <h3 style="color: #ffd700; margin-bottom: 15px;">Active Symbols by Culture</h3>
                    <div id="symbolContainer"></div>
                </div>

                <div class="evolution-timeline">
                    <h3 style="color: #ffd700; margin-bottom: 15px;">Communication Log</h3>
                    <div class="communication-log" id="commLog"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Core Data Structures
        class Symbol {
            constructor(meaning, complexity = 10, isAbstract = false, cultureName = null) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.meaning = meaning;
                this.complexity = complexity; // Stroke count
                this.usageCount = 0;
                this.generation = 0;
                this.isAbstract = isAbstract; // Phonetic vs pictographic
                this.ancestors = [];
                this.cultureName = cultureName;
                this.strokes = this.generateStrokes(meaning, complexity, isAbstract);
                this.birthGeneration = 0;
            }

            generateStrokes(meaning, complexity, isAbstract) {
                // Generate actual stroke data for drawing
                const strokes = [];
                const seed = this.stringToSeed(meaning);
                
                if (isAbstract) {
                    // Abstract symbols are simpler, more geometric
                    const numStrokes = Math.max(3, Math.floor(complexity / 2));
                    for (let i = 0; i < numStrokes; i++) {
                        const angle = (i / numStrokes) * Math.PI * 2;
                        strokes.push({
                            type: Math.random() > 0.5 ? 'line' : 'curve',
                            points: this.generateStrokePoints(angle, seed + i),
                            width: 2
                        });
                    }
                } else {
                    // Pictographic symbols are more detailed
                    const baseShape = this.getPictographicBase(meaning, seed);
                    const numStrokes = Math.max(complexity, 5);
                    
                    for (let i = 0; i < numStrokes; i++) {
                        strokes.push({
                            type: baseShape.strokeTypes[i % baseShape.strokeTypes.length],
                            points: this.generateStrokePoints(
                                (i / numStrokes) * Math.PI * 2 + baseShape.rotation,
                                seed + i,
                                baseShape.scale
                            ),
                            width: 3
                        });
                    }
                }
                
                return strokes;
            }

            stringToSeed(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            getPictographicBase(meaning, seed) {
                const bases = {
                    'sun': { strokeTypes: ['curve', 'line', 'line'], rotation: 0, scale: 1.2 },
                    'moon': { strokeTypes: ['curve', 'curve'], rotation: 0.5, scale: 1.1 },
                    'water': { strokeTypes: ['curve', 'curve', 'curve'], rotation: 0, scale: 0.8 },
                    'fire': { strokeTypes: ['line', 'curve', 'line'], rotation: Math.PI/4, scale: 1.3 },
                    'tree': { strokeTypes: ['line', 'curve', 'curve', 'line'], rotation: Math.PI/2, scale: 1.4 },
                    'house': { strokeTypes: ['line', 'line', 'line', 'line'], rotation: 0, scale: 1.0 },
                    'person': { strokeTypes: ['curve', 'line', 'line'], rotation: 0, scale: 1.0 },
                    'animal': { strokeTypes: ['curve', 'curve', 'line'], rotation: 0.3, scale: 1.1 },
                    'food': { strokeTypes: ['curve', 'curve'], rotation: 0, scale: 0.9 },
                    'tool': { strokeTypes: ['line', 'line', 'curve'], rotation: Math.PI/3, scale: 1.0 }
                };
                
                return bases[meaning] || { strokeTypes: ['line', 'curve'], rotation: 0, scale: 1.0 };
            }

            generateStrokePoints(baseAngle, seed, scale = 1.0) {
                const random = this.seededRandom(seed);
                const points = [];
                const numPoints = 3 + Math.floor(random() * 3);
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = baseAngle + (random() - 0.5) * Math.PI / 2;
                    const distance = (20 + random() * 30) * scale;
                    points.push({
                        x: Math.cos(angle) * distance,
                        y: Math.sin(angle) * distance
                    });
                }
                
                return points;
            }

            seededRandom(seed) {
                let current = seed;
                return function() {
                    current = (current * 9301 + 49297) % 233280;
                    return current / 233280;
                };
            }

            simplify() {
                if (this.complexity > 3 && this.strokes.length > 3) {
                    this.complexity -= 1;
                    // Remove a random stroke
                    const removeIdx = Math.floor(Math.random() * this.strokes.length);
                    this.strokes.splice(removeIdx, 1);
                    
                    // Simplify remaining strokes
                    this.strokes.forEach(stroke => {
                        if (stroke.points.length > 2) {
                            stroke.points.pop();
                        }
                    });
                    
                    this.usageCount = 0;
                    return true;
                }
                return false;
            }

            abstract() {
                if (!this.isAbstract) {
                    this.isAbstract = true;
                    // Regenerate with abstract style
                    this.strokes = this.generateStrokes(this.meaning, this.complexity, true);
                    return true;
                }
                return false;
            }

            clone() {
                const cloned = new Symbol(this.meaning, this.complexity, this.isAbstract, this.cultureName);
                cloned.strokes = JSON.parse(JSON.stringify(this.strokes));
                cloned.usageCount = this.usageCount;
                cloned.generation = this.generation;
                cloned.birthGeneration = this.birthGeneration;
                return cloned;
            }

            mutate() {
                // Slight variation in strokes for cultural drift
                this.strokes.forEach(stroke => {
                    stroke.points.forEach(point => {
                        point.x += (Math.random() - 0.5) * 5;
                        point.y += (Math.random() - 0.5) * 5;
                    });
                });
            }
        }

        class Agent {
            constructor(culture, x, y) {
                this.culture = culture;
                this.x = x;
                this.y = y;
                this.vocabulary = new Map(); // meaning -> Symbol
                this.communicationHistory = [];
            }

            learn(symbol) {
                if (!this.vocabulary.has(symbol.meaning)) {
                    this.vocabulary.set(symbol.meaning, symbol);
                    return true;
                }
                return false;
            }

            communicate(other, meaning) {
                if (this.vocabulary.has(meaning)) {
                    const symbol = this.vocabulary.get(meaning);
                    symbol.usageCount++;
                    
                    // Teaching
                    if (!other.vocabulary.has(meaning)) {
                        other.learn(symbol);
                        return { success: true, type: 'teach' };
                    }
                    return { success: true, type: 'communicate' };
                }
                return { success: false, type: 'fail' };
            }

            innovate(meaning, complexity, cultureName) {
                const newSymbol = new Symbol(meaning, complexity, false, cultureName);
                this.vocabulary.set(meaning, newSymbol);
                return newSymbol;
            }
        }

        class Culture {
            constructor(name, color, x, y) {
                this.name = name;
                this.color = color;
                this.x = x;
                this.y = y;
                this.agents = [];
                this.sharedSymbols = new Map();
                this.generation = 0;
            }

            addAgent(agent) {
                this.agents.push(agent);
            }

            updateSharedSymbols() {
                // Track which symbols are widely used in this culture
                const symbolCounts = new Map();
                
                this.agents.forEach(agent => {
                    agent.vocabulary.forEach((symbol, meaning) => {
                        const key = meaning;
                        symbolCounts.set(key, (symbolCounts.get(key) || 0) + 1);
                    });
                });

                // Symbols used by majority become "shared"
                const threshold = this.agents.length * 0.5;
                symbolCounts.forEach((count, meaning) => {
                    if (count >= threshold) {
                        const symbol = this.agents[0].vocabulary.get(meaning);
                        if (symbol) {
                            this.sharedSymbols.set(meaning, symbol);
                        }
                    }
                });
            }
        }

        // Simulation Engine
        class ScriptForgeSimulation {
            constructor() {
                this.cultures = [];
                this.allSymbols = [];
                this.generation = 0;
                this.isRunning = false;
                this.conceptPool = [
                    'sun', 'moon', 'water', 'fire', 'tree', 'house',
                    'person', 'animal', 'food', 'tool', 'speak', 'think',
                    'big', 'small', 'move', 'stay', 'give', 'take'
                ];
                this.communicationLog = [];
                
                // Parameters
                this.params = {
                    numCultures: 3,
                    agentsPerCulture: 8,
                    culturalIsolation: 0.3,
                    simplificationRate: 0.5,
                    innovationRate: 0.3,
                    abstractionPressure: 0.4,
                    vocabularySize: 12,
                    communicationFrequency: 0.5
                };
            }

            initialize() {
                this.cultures = [];
                this.allSymbols = [];
                this.generation = 0;
                this.communicationLog = [];

                const cultureNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon'];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#a29bfe'];

                // Create cultures
                for (let i = 0; i < this.params.numCultures; i++) {
                    const angle = (i / this.params.numCultures) * Math.PI * 2;
                    const radius = 300;
                    const x = 400 + Math.cos(angle) * radius;
                    const y = 300 + Math.sin(angle) * radius;
                    
                    const culture = new Culture(cultureNames[i], colors[i], x, y);
                    
                    // Create agents for this culture
                    for (let j = 0; j < this.params.agentsPerCulture; j++) {
                        const agentAngle = (j / this.params.agentsPerCulture) * Math.PI * 2;
                        const agentRadius = 50;
                        const agentX = x + Math.cos(agentAngle) * agentRadius;
                        const agentY = y + Math.sin(agentAngle) * agentRadius;
                        
                        const agent = new Agent(culture.name, agentX, agentY);
                        culture.addAgent(agent);
                    }
                    
                    this.cultures.push(culture);
                }

                // Initialize with basic pictographs
                this.seedInitialSymbols();
                
                this.log('Simulation initialized', 'system');
            }

            seedInitialSymbols() {
                // Each culture starts with a few basic pictographs
                const basicConcepts = this.conceptPool.slice(0, 4);
                
                this.cultures.forEach(culture => {
                    basicConcepts.forEach(concept => {
                        const symbol = new Symbol(concept, 10, false, culture.name);
                        symbol.birthGeneration = 0;
                        this.allSymbols.push(symbol);
                        
                        // Teach to a few agents in the culture
                        const numTeachers = Math.ceil(culture.agents.length * 0.3);
                        for (let i = 0; i < numTeachers; i++) {
                            culture.agents[i].learn(symbol);
                        }
                    });
                });
            }

            step() {
                if (!this.isRunning) return;

                this.generation++;

                // Each culture evolves independently
                this.cultures.forEach(culture => {
                    this.evolveCulture(culture);
                });

                // Cross-cultural contact
                if (Math.random() > this.params.culturalIsolation) {
                    this.crossCulturalContact();
                }

                // Update shared symbols
                this.cultures.forEach(culture => {
                    culture.updateSharedSymbols();
                    culture.generation++;
                });

                this.updateDisplay();
            }

            evolveCulture(culture) {
                // Communication events
                if (Math.random() < this.params.communicationFrequency) {
                    this.communicationEvent(culture);
                }

                // Innovation events
                if (Math.random() < this.params.innovationRate) {
                    this.innovationEvent(culture);
                }

                // Simplification pressure
                if (Math.random() < this.params.simplificationRate) {
                    this.simplificationEvent(culture);
                }

                // Abstraction pressure
                if (Math.random() < this.params.abstractionPressure) {
                    this.abstractionEvent(culture);
                }
            }

            communicationEvent(culture) {
                // Pick two random agents
                const agent1 = culture.agents[Math.floor(Math.random() * culture.agents.length)];
                const agent2 = culture.agents[Math.floor(Math.random() * culture.agents.length)];
                
                if (agent1 === agent2) return;

                // Pick a random concept they might need to communicate
                const concept = this.conceptPool[Math.floor(Math.random() * this.params.vocabularySize)];
                
                const result = agent1.communicate(agent2, concept);
                
                if (result.success) {
                    if (result.type === 'teach') {
                        this.log(`${culture.name}: Symbol for "${concept}" learned`, 'success');
                    }
                }
            }

            innovationEvent(culture) {
                // Agent needs to express something they can't
                const agent = culture.agents[Math.floor(Math.random() * culture.agents.length)];
                
                // Find a concept they don't have
                const neededConcepts = this.conceptPool
                    .slice(0, this.params.vocabularySize)
                    .filter(c => !agent.vocabulary.has(c));
                
                if (neededConcepts.length > 0) {
                    const concept = neededConcepts[Math.floor(Math.random() * neededConcepts.length)];
                    const complexity = 8 + Math.floor(Math.random() * 5);
                    const newSymbol = agent.innovate(concept, complexity, culture.name);
                    newSymbol.birthGeneration = this.generation;
                    this.allSymbols.push(newSymbol);
                    
                    this.log(`${culture.name}: New symbol created for "${concept}"`, 'innovation');
                }
            }

            simplificationEvent(culture) {
                // Find the most used symbols and simplify them
                const symbolUsage = new Map();
                
                culture.agents.forEach(agent => {
                    agent.vocabulary.forEach(symbol => {
                        const current = symbolUsage.get(symbol.id) || { symbol, count: 0 };
                        current.count += symbol.usageCount;
                        symbolUsage.set(symbol.id, current);
                    });
                });

                // Sort by usage
                const sorted = Array.from(symbolUsage.values())
                    .sort((a, b) => b.count - a.count);

                if (sorted.length > 0 && sorted[0].count > 10) {
                    const simplified = sorted[0].symbol.simplify();
                    if (simplified) {
                        this.log(`${culture.name}: Symbol "${sorted[0].symbol.meaning}" simplified`, 'evolution');
                    }
                }
            }

            abstractionEvent(culture) {
                // Convert pictographic symbols to abstract/phonetic ones
                const pictographicSymbols = [];
                
                culture.agents.forEach(agent => {
                    agent.vocabulary.forEach(symbol => {
                        if (!symbol.isAbstract && symbol.usageCount > 20) {
                            pictographicSymbols.push(symbol);
                        }
                    });
                });

                if (pictographicSymbols.length > 0) {
                    const symbol = pictographicSymbols[Math.floor(Math.random() * pictographicSymbols.length)];
                    const abstracted = symbol.abstract();
                    if (abstracted) {
                        this.log(`${culture.name}: Symbol "${symbol.meaning}" became abstract`, 'evolution');
                    }
                }
            }

            crossCulturalContact() {
                // Two cultures exchange knowledge
                if (this.cultures.length < 2) return;

                const c1 = this.cultures[Math.floor(Math.random() * this.cultures.length)];
                const c2 = this.cultures[Math.floor(Math.random() * this.cultures.length)];
                
                if (c1 === c2) return;

                const agent1 = c1.agents[Math.floor(Math.random() * c1.agents.length)];
                const agent2 = c2.agents[Math.floor(Math.random() * c2.agents.length)];

                // Share a random symbol
                if (agent1.vocabulary.size > 0) {
                    const symbols = Array.from(agent1.vocabulary.values());
                    const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                    agent2.learn(symbol);
                    
                    this.log(`Cross-cultural exchange: ${c1.name} ‚Üí ${c2.name}`, 'success');
                }
            }

            log(message, type = 'info') {
                this.communicationLog.unshift({ message, type, generation: this.generation });
                if (this.communicationLog.length > 50) {
                    this.communicationLog.pop();
                }
            }

            getStats() {
                const totalSymbols = new Set();
                let totalComplexity = 0;
                let complexityCount = 0;

                this.cultures.forEach(culture => {
                    culture.agents.forEach(agent => {
                        agent.vocabulary.forEach(symbol => {
                            totalSymbols.add(symbol.id);
                            totalComplexity += symbol.complexity;
                            complexityCount++;
                        });
                    });
                });

                return {
                    generation: this.generation,
                    activeSymbols: totalSymbols.size,
                    avgComplexity: complexityCount > 0 ? 
                        (totalComplexity / complexityCount).toFixed(1) : 0,
                    dialects: this.cultures.length
                };
            }

            updateDisplay() {
                const stats = this.getStats();
                document.getElementById('generationStat').textContent = stats.generation;
                document.getElementById('symbolsStat').textContent = stats.activeSymbols;
                document.getElementById('complexityStat').textContent = stats.avgComplexity;
                document.getElementById('dialectsStat').textContent = stats.dialects;

                // Update phase info
                let phase = 'Pictographic Phase';
                if (this.generation > 50) phase = 'Simplification Phase';
                if (this.generation > 100) phase = 'Abstraction Phase';
                if (this.generation > 150) phase = 'Grammar Emergence';
                document.getElementById('phaseInfo').textContent = phase;

                // Update communication log
                this.updateCommunicationLog();
                
                // Update symbol display
                this.updateSymbolDisplay();
            }

            updateCommunicationLog() {
                const logContainer = document.getElementById('commLog');
                logContainer.innerHTML = this.communicationLog.slice(0, 20).map(entry => {
                    const className = entry.type === 'success' ? 'log-success' :
                                    entry.type === 'innovation' ? 'log-innovation' :
                                    entry.type === 'evolution' ? 'log-evolution' : '';
                    return `<div class="log-entry ${className}">[Gen ${entry.generation}] ${entry.message}</div>`;
                }).join('');
            }

            updateSymbolDisplay() {
                const container = document.getElementById('symbolContainer');
                let html = '';

                this.cultures.forEach(culture => {
                    html += `<h4 style="color: ${culture.color}; margin: 15px 0 10px 0;">${culture.name} Script</h4>`;
                    html += '<div class="symbol-grid">';
                    
                    const symbolArray = Array.from(culture.sharedSymbols.values());
                    symbolArray.forEach((symbol, idx) => {
                        const canvasId = `symbol-${culture.name}-${idx}`;
                        html += `
                            <div class="symbol-card">
                                <canvas id="${canvasId}" width="80" height="80" class="symbol-canvas"></canvas>
                                <div class="symbol-meaning">${symbol.meaning}</div>
                                <div class="symbol-complexity">‚ö° ${symbol.complexity} | ${symbol.isAbstract ? 'üìù Abstract' : 'üñºÔ∏è Pictographic'}</div>
                                <div style="font-size: 0.7em; color: #666;">Gen ${symbol.birthGeneration}</div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                });

                container.innerHTML = html;

                // Now draw the symbols on their canvases
                this.cultures.forEach(culture => {
                    const symbolArray = Array.from(culture.sharedSymbols.values());
                    symbolArray.forEach((symbol, idx) => {
                        const canvasId = `symbol-${culture.name}-${idx}`;
                        const canvas = document.getElementById(canvasId);
                        if (canvas) {
                            this.drawSymbolOnCanvas(canvas, symbol, culture.color);
                        }
                    });
                });
            }

            drawSymbolOnCanvas(canvas, symbol, color) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Center the drawing
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                
                // Draw each stroke
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                symbol.strokes.forEach(stroke => {
                    ctx.lineWidth = stroke.width;
                    ctx.beginPath();
                    
                    if (stroke.points.length > 0) {
                        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                        
                        if (stroke.type === 'curve' && stroke.points.length >= 3) {
                            // Draw smooth curves
                            for (let i = 1; i < stroke.points.length - 1; i++) {
                                const xc = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
                                const yc = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
                                ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, xc, yc);
                            }
                            // Draw last segment
                            const last = stroke.points[stroke.points.length - 1];
                            ctx.lineTo(last.x, last.y);
                        } else {
                            // Draw straight lines
                            for (let i = 1; i < stroke.points.length; i++) {
                                ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                            }
                        }
                    }
                    
                    ctx.stroke();
                });
                
                ctx.restore();
            }

            start() {
                this.isRunning = true;
            }

            pause() {
                this.isRunning = false;
            }

            reset() {
                this.isRunning = false;
                this.initialize();
                this.updateDisplay();
                renderer.render();
            }
        }

        // Visualization Renderer
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.animationQueue = [];
                this.currentAnimation = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth - 40;
                this.canvas.height = 500;
            }

            render() {
                this.ctx.fillStyle = 'rgba(10, 10, 20, 0.95)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw title
                this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                this.ctx.font = 'bold 24px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Script Evolution Canvas', this.canvas.width / 2, 30);

                // Draw grid of symbols being actively written
                this.drawActiveSymbols();

                // Draw any ongoing animations
                if (this.currentAnimation) {
                    this.drawAnimation();
                }

                // Show evolution events
                this.drawEvolutionEvents();
            }

            drawActiveSymbols() {
                const ctx = this.ctx;
                const symbolsToShow = [];
                
                // Collect recent symbols from all cultures
                simulation.cultures.forEach(culture => {
                    culture.sharedSymbols.forEach(symbol => {
                        symbolsToShow.push({ symbol, culture });
                    });
                });

                // Sort by birth generation (newest first)
                symbolsToShow.sort((a, b) => b.symbol.birthGeneration - a.symbol.birthGeneration);

                // Draw in grid
                const cols = 6;
                const symbolSize = 80;
                const padding = 20;
                const startY = 60;

                symbolsToShow.slice(0, 18).forEach((item, idx) => {
                    const col = idx % cols;
                    const row = Math.floor(idx / cols);
                    const x = padding + col * (symbolSize + padding);
                    const y = startY + row * (symbolSize + padding);

                    // Draw background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(x, y, symbolSize, symbolSize);

                    // Draw border in culture color
                    ctx.strokeStyle = item.culture.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, symbolSize, symbolSize);

                    // Draw the symbol
                    ctx.save();
                    ctx.translate(x + symbolSize / 2, y + symbolSize / 2);
                    this.drawSymbol(item.symbol, item.culture.color, 0.8);
                    ctx.restore();

                    // Draw label
                    ctx.fillStyle = '#666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.symbol.meaning, x + symbolSize / 2, y + symbolSize + 12);

                    // Age indicator
                    const age = simulation.generation - item.symbol.birthGeneration;
                    const alpha = Math.max(0.3, 1 - (age / 50));
                    if (age < 10) {
                        ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                        ctx.fillText('NEW', x + symbolSize / 2, y - 5);
                    }
                });
            }

            drawSymbol(symbol, color, scale = 1.0) {
                const ctx = this.ctx;
                
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                symbol.strokes.forEach((stroke, strokeIdx) => {
                    // Fade in effect for newer strokes
                    const progress = 1.0; // Could be animated
                    ctx.globalAlpha = progress;
                    ctx.lineWidth = stroke.width * scale;
                    ctx.beginPath();
                    
                    if (stroke.points.length > 0) {
                        const p0 = stroke.points[0];
                        ctx.moveTo(p0.x * scale, p0.y * scale);
                        
                        if (stroke.type === 'curve' && stroke.points.length >= 3) {
                            for (let i = 1; i < stroke.points.length - 1; i++) {
                                const p1 = stroke.points[i];
                                const p2 = stroke.points[i + 1];
                                const xc = (p1.x + p2.x) / 2 * scale;
                                const yc = (p1.y + p2.y) / 2 * scale;
                                ctx.quadraticCurveTo(p1.x * scale, p1.y * scale, xc, yc);
                            }
                            const last = stroke.points[stroke.points.length - 1];
                            ctx.lineTo(last.x * scale, last.y * scale);
                        } else {
                            for (let i = 1; i < stroke.points.length; i++) {
                                const p = stroke.points[i];
                                ctx.lineTo(p.x * scale, p.y * scale);
                            }
                        }
                    }
                    
                    ctx.stroke();
                });
                
                ctx.globalAlpha = 1.0;
            }

            drawEvolutionEvents() {
                const ctx = this.ctx;
                const recentEvents = simulation.communicationLog.slice(0, 5);
                
                let y = this.canvas.height - 120;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(10, y - 10, this.canvas.width - 20, 110);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('Recent Evolution Events:', 20, y + 10);
                
                y += 30;
                ctx.font = '12px monospace';
                
                recentEvents.forEach((event, idx) => {
                    const alpha = 1 - (idx * 0.15);
                    const color = event.type === 'innovation' ? `rgba(251, 191, 36, ${alpha})` :
                                 event.type === 'evolution' ? `rgba(129, 140, 248, ${alpha})` :
                                 `rgba(74, 222, 128, ${alpha})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillText(`[Gen ${event.generation}] ${event.message}`, 20, y);
                    y += 18;
                });
            }

            drawAnimation() {
                // Future: animate symbol creation stroke-by-stroke
            }

            addAnimation(type, data) {
                this.animationQueue.push({ type, data, frame: 0 });
            }
        }

        // Export Manager
        class ExportManager {
            constructor(simulation) {
                this.simulation = simulation;
            }

            exportAsPNG() {
                // Create a high-res canvas for export
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = 2400;
                exportCanvas.height = 1800;
                const ctx = exportCanvas.getContext('2d');

                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                // Title
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Evolved Script System', exportCanvas.width / 2, 80);

                ctx.font = '24px sans-serif';
                ctx.fillStyle = '#a0a0a0';
                ctx.fillText(`Generation ${this.simulation.generation}`, exportCanvas.width / 2, 120);

                // Draw each culture's script
                let yOffset = 200;
                const colWidth = exportCanvas.width / this.simulation.cultures.length;

                this.simulation.cultures.forEach((culture, cultureIdx) => {
                    const xOffset = cultureIdx * colWidth + colWidth / 2;

                    // Culture name
                    ctx.fillStyle = culture.color;
                    ctx.font = 'bold 32px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${culture.name} Script`, xOffset, yOffset);

                    // Draw symbols in grid
                    const symbols = Array.from(culture.sharedSymbols.values());
                    const cols = 4;
                    const symbolSize = 120;
                    const padding = 20;
                    let x = xOffset - (cols * (symbolSize + padding)) / 2;
                    let y = yOffset + 50;

                    symbols.forEach((symbol, idx) => {
                        const col = idx % cols;
                        const row = Math.floor(idx / cols);
                        const sx = x + col * (symbolSize + padding);
                        const sy = y + row * (symbolSize + padding);

                        // Draw symbol background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(sx, sy, symbolSize, symbolSize);

                        ctx.strokeStyle = culture.color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(sx, sy, symbolSize, symbolSize);

                        // Draw the symbol
                        ctx.save();
                        ctx.translate(sx + symbolSize / 2, sy + symbolSize / 2);
                        this.drawSymbolForExport(ctx, symbol, culture.color, 1.2);
                        ctx.restore();

                        // Label
                        ctx.fillStyle = '#e0e0e0';
                        ctx.font = '16px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(symbol.meaning, sx + symbolSize / 2, sy + symbolSize + 20);

                        // Stats
                        ctx.fillStyle = '#666';
                        ctx.font = '12px sans-serif';
                        ctx.fillText(`‚ö°${symbol.complexity} Gen${symbol.birthGeneration}`, sx + symbolSize / 2, sy + symbolSize + 38);
                    });
                });

                // Convert to blob and download
                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scriptforge-gen${this.simulation.generation}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }

            exportAsSVG() {
                let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="2400" height="1800" viewBox="0 0 2400 1800">
    <rect width="2400" height="1800" fill="#1a1a2e"/>
    
    <text x="1200" y="80" font-size="48" font-weight="bold" fill="#ffd700" text-anchor="middle">Evolved Script System</text>
    <text x="1200" y="120" font-size="24" fill="#a0a0a0" text-anchor="middle">Generation ${this.simulation.generation}</text>
`;

                const colWidth = 2400 / this.simulation.cultures.length;
                let yOffset = 200;

                this.simulation.cultures.forEach((culture, cultureIdx) => {
                    const xOffset = cultureIdx * colWidth + colWidth / 2;

                    svg += `<text x="${xOffset}" y="${yOffset}" font-size="32" font-weight="bold" fill="${culture.color}" text-anchor="middle">${culture.name} Script</text>\n`;

                    const symbols = Array.from(culture.sharedSymbols.values());
                    const cols = 4;
                    const symbolSize = 120;
                    const padding = 20;
                    const startX = xOffset - (cols * (symbolSize + padding)) / 2;
                    const startY = yOffset + 50;

                    symbols.forEach((symbol, idx) => {
                        const col = idx % cols;
                        const row = Math.floor(idx / cols);
                        const sx = startX + col * (symbolSize + padding);
                        const sy = startY + row * (symbolSize + padding);

                        svg += `<rect x="${sx}" y="${sy}" width="${symbolSize}" height="${symbolSize}" fill="rgba(0,0,0,0.5)" stroke="${culture.color}" stroke-width="2"/>\n`;

                        // Draw symbol strokes
                        const cx = sx + symbolSize / 2;
                        const cy = sy + symbolSize / 2;

                        symbol.strokes.forEach(stroke => {
                            if (stroke.points.length > 0) {
                                let pathData = `M ${cx + stroke.points[0].x * 1.2} ${cy + stroke.points[0].y * 1.2}`;

                                if (stroke.type === 'curve' && stroke.points.length >= 3) {
                                    for (let i = 1; i < stroke.points.length - 1; i++) {
                                        const p1 = stroke.points[i];
                                        const p2 = stroke.points[i + 1];
                                        const xc = (p1.x + p2.x) / 2 * 1.2;
                                        const yc = (p1.y + p2.y) / 2 * 1.2;
                                        pathData += ` Q ${cx + p1.x * 1.2} ${cy + p1.y * 1.2} ${cx + xc} ${cy + yc}`;
                                    }
                                    const last = stroke.points[stroke.points.length - 1];
                                    pathData += ` L ${cx + last.x * 1.2} ${cy + last.y * 1.2}`;
                                } else {
                                    for (let i = 1; i < stroke.points.length; i++) {
                                        pathData += ` L ${cx + stroke.points[i].x * 1.2} ${cy + stroke.points[i].y * 1.2}`;
                                    }
                                }

                                svg += `<path d="${pathData}" stroke="${culture.color}" stroke-width="${stroke.width}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>\n`;
                            }
                        });

                        svg += `<text x="${cx}" y="${sy + symbolSize + 20}" font-size="16" fill="#e0e0e0" text-anchor="middle">${symbol.meaning}</text>\n`;
                        svg += `<text x="${cx}" y="${sy + symbolSize + 38}" font-size="12" fill="#666" text-anchor="middle">‚ö°${symbol.complexity} Gen${symbol.birthGeneration}</text>\n`;
                    });
                });

                svg += '</svg>';

                const blob = new Blob([svg], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `scriptforge-gen${this.simulation.generation}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            }

            exportAsJSON() {
                const data = {
                    metadata: {
                        generation: this.simulation.generation,
                        timestamp: new Date().toISOString(),
                        parameters: this.simulation.params
                    },
                    cultures: this.simulation.cultures.map(culture => ({
                        name: culture.name,
                        color: culture.color,
                        generation: culture.generation,
                        symbols: Array.from(culture.sharedSymbols.values()).map(symbol => ({
                            id: symbol.id,
                            meaning: symbol.meaning,
                            complexity: symbol.complexity,
                            isAbstract: symbol.isAbstract,
                            usageCount: symbol.usageCount,
                            birthGeneration: symbol.birthGeneration,
                            strokes: symbol.strokes
                        }))
                    })),
                    stats: this.simulation.getStats()
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `scriptforge-gen${this.simulation.generation}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            exportManuscript() {
                // Create a beautiful manuscript-style document
                const manuscriptCanvas = document.createElement('canvas');
                manuscriptCanvas.width = 2480; // A4 at 300 DPI
                manuscriptCanvas.height = 3508;
                const ctx = manuscriptCanvas.getContext('2d');

                // Parchment background
                ctx.fillStyle = '#f4f1e8';
                ctx.fillRect(0, 0, manuscriptCanvas.width, manuscriptCanvas.height);

                // Add texture
                ctx.fillStyle = 'rgba(139, 119, 101, 0.05)';
                for (let i = 0; i < 1000; i++) {
                    ctx.fillRect(
                        Math.random() * manuscriptCanvas.width,
                        Math.random() * manuscriptCanvas.height,
                        2, 2
                    );
                }

                // Border
                ctx.strokeStyle = '#8b7765';
                ctx.lineWidth = 8;
                ctx.strokeRect(60, 60, manuscriptCanvas.width - 120, manuscriptCanvas.height - 120);

                // Decorative corners
                ctx.fillStyle = '#8b7765';
                [
                    [60, 60], [manuscriptCanvas.width - 60, 60],
                    [60, manuscriptCanvas.height - 60], [manuscriptCanvas.width - 60, manuscriptCanvas.height - 60]
                ].forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Title
                ctx.fillStyle = '#2c1810';
                ctx.font = 'bold 72px serif';
                ctx.textAlign = 'center';
                ctx.fillText('Codex of Emergent Scripts', manuscriptCanvas.width / 2, 200);

                ctx.font = 'italic 32px serif';
                ctx.fillStyle = '#5c4a3a';
                ctx.fillText(`Generation ${this.simulation.generation} ‚Ä¢ ${new Date().toLocaleDateString()}`, manuscriptCanvas.width / 2, 260);

                // Introduction text
                ctx.font = '24px serif';
                ctx.fillStyle = '#2c1810';
                ctx.textAlign = 'left';
                const introText = 'Herein lies a complete record of writing systems evolved through';
                const introText2 = 'computational emergence, demonstrating how complex scripts arise';
                const introText3 = 'from simple communication needs across isolated cultures.';
                ctx.fillText(introText, 120, 340);
                ctx.fillText(introText2, 120, 375);
                ctx.fillText(introText3, 120, 410);

                // Draw each culture's script section
                let yPos = 500;
                const sectionHeight = 800;

                this.simulation.cultures.forEach((culture, idx) => {
                    if (yPos > 3200) return; // Don't overflow page

                    // Section header
                    ctx.fillStyle = culture.color;
                    ctx.font = 'bold 48px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`The ${culture.name} Script`, manuscriptCanvas.width / 2, yPos);

                    ctx.fillStyle = '#5c4a3a';
                    ctx.font = 'italic 20px serif';
                    ctx.fillText(`${culture.sharedSymbols.size} symbols ‚Ä¢ Generation ${culture.generation}`, manuscriptCanvas.width / 2, yPos + 35);

                    // Horizontal divider
                    ctx.strokeStyle = culture.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(200, yPos + 50);
                    ctx.lineTo(manuscriptCanvas.width - 200, yPos + 50);
                    ctx.stroke();

                    // Draw symbols
                    const symbols = Array.from(culture.sharedSymbols.values());
                    const cols = 6;
                    const symbolSize = 150;
                    const padding = 40;
                    const startX = (manuscriptCanvas.width - (cols * (symbolSize + padding))) / 2;
                    let gridY = yPos + 100;

                    symbols.forEach((symbol, idx) => {
                        const col = idx % cols;
                        const row = Math.floor(idx / cols);
                        const sx = startX + col * (symbolSize + padding);
                        const sy = gridY + row * (symbolSize + padding);

                        // Symbol background
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(sx, sy, symbolSize, symbolSize);

                        ctx.strokeStyle = '#d4c5b0';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(sx, sy, symbolSize, symbolSize);

                        // Draw symbol
                        ctx.save();
                        ctx.translate(sx + symbolSize / 2, sy + symbolSize / 2);
                        this.drawSymbolForExport(ctx, symbol, culture.color, 1.5);
                        ctx.restore();

                        // Label with illuminated letter style
                        ctx.fillStyle = '#2c1810';
                        ctx.font = 'bold 18px serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(symbol.meaning.toUpperCase(), sx + symbolSize / 2, sy + symbolSize + 25);

                        // Small stats
                        ctx.fillStyle = '#8b7765';
                        ctx.font = '14px serif';
                        const typeText = symbol.isAbstract ? 'Abstract' : 'Pictographic';
                        ctx.fillText(`${typeText} ‚Ä¢ ${symbol.complexity} strokes`, sx + symbolSize / 2, sy + symbolSize + 45);
                    });

                    yPos += sectionHeight;
                });

                // Footer
                ctx.fillStyle = '#8b7765';
                ctx.font = 'italic 18px serif';
                ctx.textAlign = 'center';
                ctx.fillText('Generated by ScriptForge ‚Ä¢ Forge Theory in Action', manuscriptCanvas.width / 2, manuscriptCanvas.height - 100);
                ctx.fillText('Complexity emerges from the simple need to communicate', manuscriptCanvas.width / 2, manuscriptCanvas.height - 70);

                // Convert to blob and download
                manuscriptCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scriptforge-manuscript-gen${this.simulation.generation}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }

            drawSymbolForExport(ctx, symbol, color, scale) {
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                symbol.strokes.forEach(stroke => {
                    ctx.lineWidth = stroke.width * scale;
                    ctx.beginPath();

                    if (stroke.points.length > 0) {
                        const p0 = stroke.points[0];
                        ctx.moveTo(p0.x * scale, p0.y * scale);

                        if (stroke.type === 'curve' && stroke.points.length >= 3) {
                            for (let i = 1; i < stroke.points.length - 1; i++) {
                                const p1 = stroke.points[i];
                                const p2 = stroke.points[i + 1];
                                const xc = (p1.x + p2.x) / 2 * scale;
                                const yc = (p1.y + p2.y) / 2 * scale;
                                ctx.quadraticCurveTo(p1.x * scale, p1.y * scale, xc, yc);
                            }
                            const last = stroke.points[stroke.points.length - 1];
                            ctx.lineTo(last.x * scale, last.y * scale);
                        } else {
                            for (let i = 1; i < stroke.points.length; i++) {
                                const p = stroke.points[i];
                                ctx.lineTo(p.x * scale, p.y * scale);
                            }
                        }
                    }

                    ctx.stroke();
                });
            }
        }

        // Initialize
        const canvas = document.getElementById('mainCanvas');
        const simulation = new ScriptForgeSimulation();
        const renderer = new Renderer(canvas);
        const exporter = new ExportManager(simulation);

        simulation.initialize();
        renderer.render();

        // Animation loop
        function animate() {
            if (simulation.isRunning) {
                simulation.step();
                renderer.render();
            }
            requestAnimationFrame(animate);
        }
        animate();

        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            simulation.start();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            simulation.pause();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            simulation.reset();
        });

        // Export buttons
        document.getElementById('exportPngBtn').addEventListener('click', () => {
            simulation.pause();
            exporter.exportAsPNG();
        });

        document.getElementById('exportSvgBtn').addEventListener('click', () => {
            simulation.pause();
            exporter.exportAsSVG();
        });

        document.getElementById('exportJsonBtn').addEventListener('click', () => {
            simulation.pause();
            exporter.exportAsJSON();
        });

        document.getElementById('exportManuscriptBtn').addEventListener('click', () => {
            simulation.pause();
            exporter.exportManuscript();
        });

        // Parameter controls
        function setupSlider(sliderId, valueId, param, suffix = '', multiplier = 1) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) * multiplier;
                simulation.params[param] = value;
                valueDisplay.textContent = e.target.value + suffix;
            });
        }

        setupSlider('culturesSlider', 'culturesValue', 'numCultures', '', 1);
        setupSlider('agentsSlider', 'agentsValue', 'agentsPerCulture', '', 1);
        setupSlider('isolationSlider', 'isolationValue', 'culturalIsolation', '%', 0.01);
        setupSlider('simplificationSlider', 'simplificationValue', 'simplificationRate', '%', 0.01);
        setupSlider('innovationSlider', 'innovationValue', 'innovationRate', '%', 0.01);
        setupSlider('abstractionSlider', 'abstractionValue', 'abstractionPressure', '%', 0.01);
        setupSlider('vocabSlider', 'vocabValue', 'vocabularySize', '', 1);
        setupSlider('commFreqSlider', 'commFreqValue', 'communicationFrequency', '%', 0.01);
    </script>
</body>
</html>